
为了获取HTTP事务请求方方面面的完整信息-你不得不使用比LWP::Simple更强大的模块，使用以面向对象作为核心思想的LWP套件。这个单元介绍使用LWP作为浏览器对象（使用它来发送请求）和响应对象（得到请求的返回结果）。你可以学习到使用基本的方法来构造请求和检查响应结果，这些技能将会在后续的章节如cookies,语言选择，爬虫等中用得到。

### 3.1. 基本模块 (The Basic Classes)

在LWP模块中，通过LWP::UserAgent中的浏览器对象执行GET,HEAD,POST请求，处理HTTP响应结果的模块叫HTTP::Response。这两个是主要对象，还有一些其他模块提供cookie管理或者用户代理功能可以用来做爬虫。还有一些对象用来处理非HTTP方向的web,像HTML模块。在这一章，我们使用这些模块来执行web请求。

逐个添加如下模块：
```sh
use LWP::UserAgent;
use HTTP::Response;
```
但是加载LWP::UserAgent和LWP::Response 使用如下方法最简单方便：
```sh
use LWP;               # same as previous two lines
```

如果你熟悉perl的面向对象编程，LWP模块会带给你一些真正的惊喜。你只需要知道这些基本的对象和访问函数的名字就可以了。如果你不了解面向对象编程，你需要掌握一下。附录G，“User's View of Object-Oriented Modules”将会给你提供一些面向对象的概念。想学习更多（包括如何写自己的对象），可以查看Programming Perl(O'Reilly)。


### 3.2. 使用LWP模块编程

第一步是初始化浏览器对象，他可以被用在程序中的其他地方。
The first step in writing a program that uses the LWP classes is to create and initialize the browser object, which can be used throughout the rest of the program. You need a browser object to perform HTTP requests, and although you could use several browser objects per program, I've never run into a reason to use more than one.

The browser object can use a proxy (a server that fetches web pages for you, such as a firewall, or a web cache such as Squid). It's good form to check the environment for proxy settings by calling env_proxy():

use LWP::UserAgent;
my $browser = LWP::UserAgent->new( );
$browser->env_proxy( ); # if we're behind a firewall

That's all the initialization that most user agents will ever need. Once you've done that, you usually won't do anything with it for the rest of the program, aside from calling its get( ), head( ), or post( ) methods, to get what's at a URL, or to perform HTTP HEAD or POST requests on it. For example:

$url = 'http://www.guardian.co.uk/';
my $response = $browser->get($url);

Then you call methods on the response to check the status, extract the content, and so on. For example, this code checks to make sure we successfully fetched an HTML document that isn't worryingly short, then prints a message depending on whether the words "Madonna" or "Arkansas" appear in the content:

die "Hmm, error \"", $response->status_line( ),
  "\" when getting $url"  unless $response->is_success( );
my $content_type = $response->content_type( );
die "Hm, unexpected content type $content_type from $url"
   unless $content_type eq 'text/html';
my $content = $response->content( );
die "Odd, the content from $url is awfully short!"
   if length($content) < 3000;
if($content =~ m/Madonna|Arkansas/i) {
   print "<!-- The news today is IMPORTANT -->\n",
         $content;
} else {
   print "$url has no news of ANY CONCEIVABLE IMPORTANCE!\n";
}

As you see, the response object contains all the data from the web server's response (or an error message about how that server wasn't reachable!), and we use method calls to get at the data. There are accessors for the different parts of the response (e.g., the status line) and convenience functions to tell us whether the response was successful (is_success( )).

And that's a working and complete LWP program!
